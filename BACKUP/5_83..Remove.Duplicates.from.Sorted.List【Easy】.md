# [83. Remove Duplicates from Sorted List【Easy】](https://github.com/Urchinzhou/Keep-ARTS/issues/5)

# 遍历
```C
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */


struct ListNode* deleteDuplicates(struct ListNode* head){
    if(!head)
        return NULL;
    struct ListNode *tmp = head;
    while(tmp->next !=NULL){
        if(tmp->val == tmp->next->val)
            tmp->next = tmp->next->next;
        else
            tmp = tmp->next;
    }
    return head;
}

```

# 递归

1. 找终止条件：当head指向链表只剩一个元素的时候，自然是不可能重复的，因此return
2. 想想应该返回什么值：应该返回的自然是已经去重的链表的头节点
3. 每一步要做什么：宏观上考虑，此时head.next已经指向一个去重的链表了，而根据第二步，我应该返回一个去重的链表的头节点。因此这一步应该做的是判断当前的head和head.next是否相等，如果相等则说明重了，返回head.next，否则返回head

```C
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */


struct ListNode* deleteDuplicates(struct ListNode* head){
    if(!head || head->next == NULL)
        return head;

    head->next = deleteDuplicates(head->next);
    if(head->val == head->next->val)
        head = head->next;
    return head;
}

```